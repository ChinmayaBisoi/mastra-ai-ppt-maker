"use client";

import BreadcrumbHeader from "@/components/breadcrumb-header";
import PageLayout from "@/components/layouts/page-layout";
import { OutlineSection } from "@/components/v0/outline-section";
import SliderFrame from "@/components/v0/slide-frame";
import { generateSlidesSequentially } from "@/components/v0/slide-generator";
import {
  saveSlidesToDatabase,
  updateSlideCode,
  type Slide,
} from "@/components/v0/slide-saver";
import { exportSlidesToPPTX } from "@/components/v0/export-to-pptx";
import { presentationOutlineSchema } from "@/schema/ppt-outline";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { FileDown, InfoIcon, Loader2 } from "lucide-react";
import { Suspense, useCallback, useEffect, useRef, useState } from "react";
import { useParams } from "next/navigation";
import type { z } from "zod";

type PresentationOutline = z.infer<typeof presentationOutlineSchema>;

interface PresentationData {
  id: string;
  outline: PresentationOutline | null;
  slides: Slide[] | null;
  designStyle: {
    designGuide?: string;
    colors?: Record<string, string>;
  } | null;
}

export default function PresentationEditorPage() {
  const params = useParams();
  const presentationId = params.presentationId as string;

  const [presentation, setPresentation] = useState<PresentationData | null>(
    null
  );
  const [loading, setLoading] = useState(true);
  const [slides, setSlides] = useState<Slide[]>([]);
  const [isGenerating, setIsGenerating] = useState(false);
  const [downloadLoading, setDownloadLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const hasAutoGeneratedRef = useRef(false);

  const fetchPresentation = async () => {
    console.log("Fetching presentation", presentationId);
    let hasSlides = false;
    try {
      setLoading(true);
      const response = await fetch(`/api/presentations/${presentationId}`);

      if (!response.ok) {
        if (response.status === 404) {
          setError("Presentation not found");
        } else {
          setError("Failed to load presentation");
        }
        return;
      }

      const data = await response.json();
      setPresentation({
        id: data.id,
        outline: data.outline as PresentationOutline | null,
        slides: (data.slides as Slide[]) || null,
        designStyle:
          (data.designStyle as {
            designGuide?: string;
            colors?: Record<string, string>;
          }) || null,
      });

      setSlides(data.slides as Slide[]);

      if (!!data && !!data.slides && data.slides.length > 0) {
        hasSlides = true;
      }
    } catch (err) {
      console.error("Error fetching presentation:", err);
      setError("Failed to load presentation");
    } finally {
      setLoading(false);
    }

    console.log("hasSlides", hasSlides);

    if (!hasSlides) {
      generateSlides();
    }
  };

  const hasValidSlides = (slides: Slide[] | null | undefined): boolean => {
    if (!slides || !Array.isArray(slides)) return false;
    if (slides.length === 0) return false;
    // Check if slides have actual content (not just empty code)
    return slides.some((slide) => slide?.code && slide.code.trim().length > 0);
  };

  const generateSlides = useCallback(async () => {
    if (!presentation?.outline || isGenerating) return;

    // Don't generate if slides already exist with content
    if (hasValidSlides(presentation.slides)) {
      console.log("Slides already exist, skipping generation");
      return;
    }

    setIsGenerating(true);
    setError(null);
    hasAutoGeneratedRef.current = true;

    try {
      const designStyle = presentation.designStyle || {
        designGuide: "Modern Dark style",
        colors: {
          primary: "#0D0D0D",
          secondary: "#1F1F1F",
          accent: "#FFD700",
          background: "#0D0D0D",
        },
      };

      const generatedSlides = await generateSlidesSequentially(
        presentation.outline,
        designStyle,
        designStyle.colors,
        (index, total, html) => {
          // Update slides in real-time as they're generated
          setSlides((prev) => {
            const updated = [...prev];
            updated[index] = { code: html };
            return updated;
          });
        }
      );

      setSlides(generatedSlides);
      await saveSlidesToDatabase(presentationId, generatedSlides);
    } catch (err) {
      console.error("Error generating slides:", err);
      setError("Failed to generate slides. Please try again.");
    } finally {
      setIsGenerating(false);
    }
  }, [presentation, isGenerating, presentationId]);

  useEffect(() => {
    if (presentationId) {
      fetchPresentation();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [presentationId]);

  // useEffect(() => {
  //   // Early return if already generating or already auto-generated
  //   if (hasAutoGeneratedRef.current || isGenerating) {
  //     return;
  //   }

  //   if (
  //     presentation?.slides &&
  //     Array.isArray(presentation.slides) &&
  //     presentation.slides.length > 0
  //   ) {
  //     // Load existing slides
  //     setSlides(presentation.slides);
  //     hasAutoGeneratedRef.current = false; // Reset if slides are loaded
  //   } else if (
  //     presentation?.outline &&
  //     (!presentation.slides ||
  //       (Array.isArray(presentation.slides) &&
  //         presentation.slides.length === 0))
  //   ) {
  //     // Auto-generate slides if outline exists but slides don't (only once)
  //     hasAutoGeneratedRef.current = true;
  //     generateSlides();
  //   }
  // }, [presentation, isGenerating]);

  const handleSlideUpdate = async (index: number, code: string) => {
    const updatedSlides = [...slides];
    updatedSlides[index] = { code };
    setSlides(updatedSlides);

    // Auto-save to database
    try {
      await updateSlideCode(presentationId, index, code, slides);
    } catch (err) {
      console.error("Error saving slide:", err);
    }
  };

  const handleExportPPTX = async () => {
    if (!containerRef.current) return;

    setDownloadLoading(true);
    try {
      if (containerRef.current) {
        await exportSlidesToPPTX(containerRef, "MyProjectSlides.pptx");
      }
    } catch (err) {
      console.error("Error exporting PPTX:", err);
      setError("Failed to export presentation. Please try again.");
    } finally {
      setDownloadLoading(false);
    }
  };

  const colors = presentation?.designStyle?.colors || {};

  if (loading) {
    return (
      <Suspense fallback={<div>Suspense Loading...</div>}>
        <BreadcrumbHeader title="Create" href="/create" />
        <PageLayout
          title="Create Presentation"
          description="Design beautiful presentations with AI assistance"
        >
          <div className="flex items-center justify-center h-64">
            <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
          </div>
        </PageLayout>
      </Suspense>
    );
  }

  if (error && !presentation) {
    return (
      <Suspense fallback={<div>Suspense Loading...</div>}>
        <BreadcrumbHeader title="Create" href="/create" />
        <PageLayout
          title="Create Presentation"
          description="Design beautiful presentations with AI assistance"
        >
          <Alert variant="destructive">
            <AlertTitle>Error</AlertTitle>
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        </PageLayout>
      </Suspense>
    );
  }

  return (
    <Suspense fallback={<div>Suspense Loading...</div>}>
      <BreadcrumbHeader title="Create" href="/create" />
      <PageLayout
        title="Create Presentation"
        description="Design beautiful presentations with AI assistance"
      >
        <div className="space-y-4">
          <div className="grid grid-cols-5 gap-6 pb-4">
            {/* Outline Section - Left */}
            <div className="col-span-2 overflow-auto">
              <OutlineSection
                outline={presentation?.outline || null}
                loading={loading}
                editable={false}
              />
            </div>

            {/* Slides Section - Right */}
            <div className="col-span-3 overflow-auto" ref={containerRef}>
              {isGenerating && slides.length === 0 && (
                <div className="flex items-center justify-center h-64">
                  <div className="text-center">
                    <Loader2 className="h-8 w-8 animate-spin mx-auto mb-2" />
                    <p className="text-sm text-muted-foreground">
                      Generating slides...
                    </p>
                  </div>
                </div>
              )}

              {slides.map((slide, index) => (
                <SliderFrame
                  key={index}
                  slide={slide}
                  colors={colors}
                  setUpdateSlider={(code) => handleSlideUpdate(index, code)}
                />
              ))}

              {!isGenerating &&
                slides.length === 0 &&
                presentation?.outline && (
                  <div className="flex items-center justify-center h-64">
                    <Button onClick={generateSlides} size="lg">
                      Generate Slides
                    </Button>
                  </div>
                )}
            </div>
          </div>

          {/* Export Button */}
          {slides.length > 0 && (
            <Button
              onClick={handleExportPPTX}
              size="lg"
              className="fixed bottom-6 left-1/2 transform -translate-x-1/2"
              disabled={downloadLoading || isGenerating}
            >
              {downloadLoading ? (
                <Loader2 className="h-4 w-4 animate-spin mr-2" />
              ) : (
                <FileDown className="h-4 w-4 mr-2" />
              )}
              Export PPT
            </Button>
          )}
        </div>
      </PageLayout>
    </Suspense>
  );
}
